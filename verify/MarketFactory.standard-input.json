{
  "language": "Solidity",
  "settings": {
    "evmVersion": "shanghai",
    "outputSelection": {
      "*": {
        "": [
          "ast"
        ],
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ]
      }
    },
    "remappings": [
      "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
    ]
  },
  "sources": {
    "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "project/contracts/MarketFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"./ProhesisPredictionMarket.sol\";\n\n/**\n * @title MarketFactory\n * @notice Deploys and tracks ProhesisPredictionMarket instances.\n * The owner (deployer) can create markets and optionally set fees.\n */\n\ncontract MarketFactory {\n    address public owner;\n    uint256 public creationFee; // optional ETH fee for creating a market\n    uint256 public minBet; // optional minimum bet for markets (enforced in UI)\n    address public feeRecipient; // protocol fee recipient for all markets\n    uint16 public feeBps; // e.g., 100 = 1%\n    address[] public allMarkets;\n\n    event MarketCreated(address indexed market, string title, uint256 endTime, address creator);\n    event FeeUpdated(uint256 newFee);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    constructor(address _feeRecipient, uint16 _feeBps, uint256 _minBet) {\n        owner = msg.sender;\n        creationFee = 0 ether; // set if you want to charge e.g. 0.01 ether\n        feeRecipient = _feeRecipient;\n        feeBps = _feeBps;\n        minBet = _minBet;\n    }\n\n    // ============ Create Market ============\n    function createMarket(string memory _title, uint256 _endTime) external payable {\n        require(msg.value >= creationFee, \"Insufficient creation fee\");\n\n        ProhesisPredictionMarket market = new ProhesisPredictionMarket();\n        // pass sender as creator and propagate protocol fee params\n        market.initialize(_title, _endTime, msg.sender, feeRecipient, feeBps);\n\n        allMarkets.push(address(market));\n\n        emit MarketCreated(address(market), _title, _endTime, msg.sender);\n\n        // transfer fee to owner\n        if (creationFee > 0) {\n            (bool sent, ) = payable(owner).call{value: creationFee}(\"\");\n            require(sent, \"Fee transfer failed\");\n        }\n    }\n\n    // ============ Owner Functions ============\n    function updateCreationFee(uint256 _fee) external onlyOwner {\n        creationFee = _fee;\n        emit FeeUpdated(_fee);\n    }\n\n    function updateFeeParams(address _recipient, uint16 _bps) external onlyOwner {\n        feeRecipient = _recipient;\n        feeBps = _bps;\n    }\n\n    function updateMinBet(uint256 _minBet) external onlyOwner {\n        minBet = _minBet;\n    }\n\n    function withdraw() external onlyOwner {\n        uint256 bal = address(this).balance;\n        require(bal > 0, \"No balance\");\n        (bool sent, ) = payable(owner).call{value: bal}(\"\");\n        require(sent, \"Withdraw failed\");\n    }\n\n    // ============ View ============\n    function getAllMarkets() external view returns (address[] memory) {\n        return allMarkets;\n    }\n\n    function totalMarkets() external view returns (uint256) {\n        return allMarkets.length;\n    }\n\n    receive() external payable {}\n}\n"
    },
    "project/contracts/ProhesisPredictionMarket.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title ProhesisPredictionMarket\n * @notice Handles an individual market where users can bet YES or NO using ETH.\n * Creator can resolve it once the end time passes, and winners can claim their payouts.\n */\n\ncontract ProhesisPredictionMarket is ReentrancyGuard {\n    // ============ State Variables ============\n    address public creator;\n    address public feeRecipient; // protocol fee recipient\n    uint16 public feeBps; // e.g., 100 = 1%\n    string public title;\n    uint256 public endTime;\n\n    uint256 public totalYesPool;\n    uint256 public totalNoPool;\n    bool public resolved;\n    bool public canceled; // allow creator to cancel before end\n    uint8 public winningOutcome; // 1 = YES, 0 = NO\n    bool public initialized;\n\n    mapping(address => uint256) public yesBets;\n    mapping(address => uint256) public noBets;\n    mapping(address => bool) public hasClaimed;\n\n    // ============ Events ============\n    event BetPlaced(address indexed user, bool choice, uint256 amount);\n    event MarketResolved(uint8 outcome);\n    event WinningsClaimed(address indexed user, uint256 amount, uint256 fee);\n    event MarketCanceled();\n\n    // ============ Modifiers ============\n    modifier onlyCreator() {\n        require(msg.sender == creator, \"Not creator\");\n        _;\n    }\n\n    modifier marketActive() {\n        require(block.timestamp < endTime, \"Market ended\");\n        require(!resolved, \"Market resolved\");\n        _;\n    }\n\n    modifier marketEnded() {\n        require(block.timestamp >= endTime, \"Market not ended\");\n        _;\n    }\n\n    modifier onlyUninitialized() {\n        require(!initialized, \"initialized\");\n        _;\n    }\n\n    // ============ Initialization ============\n    // initialize now accepts an explicit creator address so the factory can set\n    // the true human/owner as creator (previously the factory contract became\n    // the creator which prevented creators from calling onlyCreator functions).\n    function initialize(string memory _title, uint256 _endTime, address _creator, address _feeRecipient, uint16 _feeBps)\n        external\n        onlyUninitialized\n    {\n        require(_endTime > block.timestamp + 5 minutes, \"Invalid end time\");\n        title = _title;\n        endTime = _endTime;\n        creator = _creator;\n        feeRecipient = _feeRecipient;\n        feeBps = _feeBps;\n        initialized = true;\n    }\n\n    // ============ Betting ============\n    function placeBet(bool _choice) external payable marketActive {\n        require(msg.value > 0, \"Zero bet not allowed\");\n\n        if (_choice) {\n            yesBets[msg.sender] += msg.value;\n            totalYesPool += msg.value;\n        } else {\n            noBets[msg.sender] += msg.value;\n            totalNoPool += msg.value;\n        }\n\n        emit BetPlaced(msg.sender, _choice, msg.value);\n    }\n\n    // ============ View Functions ============\n    function getPoolTotals() external view returns (uint256 yes, uint256 no) {\n        return (totalYesPool, totalNoPool);\n    }\n\n    function getUserBet(address user)\n        external\n        view\n        returns (uint256 yes, uint256 no)\n    {\n        return (yesBets[user], noBets[user]);\n    }\n\n    function getTotalPool() public view returns (uint256) {\n        return totalYesPool + totalNoPool;\n    }\n\n    // ============ Resolve Market ============\n    function resolve(uint8 _winningOutcome)\n        external\n        onlyCreator\n        marketEnded\n    {\n        require(!resolved, \"Already resolved\");\n        require(!canceled, \"Market canceled\");\n        require(_winningOutcome == 0 || _winningOutcome == 1, \"Invalid outcome\");\n\n        resolved = true;\n        winningOutcome = _winningOutcome;\n\n        emit MarketResolved(_winningOutcome);\n    }\n\n    // ============ Claim Winnings ============\n    function claimWinnings() external nonReentrant {\n        require(resolved, \"Not resolved yet\");\n        require(!hasClaimed[msg.sender], \"Already claimed\");\n\n        uint256 payout = 0;\n\n        if (winningOutcome == 1 && yesBets[msg.sender] > 0) {\n            payout = (yesBets[msg.sender] * getTotalPool()) / totalYesPool;\n        } else if (winningOutcome == 0 && noBets[msg.sender] > 0) {\n            payout = (noBets[msg.sender] * getTotalPool()) / totalNoPool;\n        }\n\n        require(payout > 0, \"Not eligible\");\n\n        // protocol fee\n        uint256 fee = (payout * feeBps) / 10_000;\n        uint256 sendAmount = payout - fee;\n\n        hasClaimed[msg.sender] = true;\n        if (fee > 0 && feeRecipient != address(0)) {\n            (bool fs, ) = payable(feeRecipient).call{value: fee}(\"\");\n            require(fs, \"Fee transfer failed\");\n        }\n        (bool success, ) = payable(msg.sender).call{value: sendAmount}(\"\");\n        require(success, \"Transfer failed\");\n\n        emit WinningsClaimed(msg.sender, sendAmount, fee);\n    }\n\n    // Cancel market before end time; refunds both pools proportionally via manual claim path\n    function cancel() external onlyCreator {\n        require(!resolved, \"Resolved\");\n        require(!canceled, \"Canceled\");\n        require(block.timestamp < endTime, \"Already ended\");\n        canceled = true;\n        emit MarketCanceled();\n    }\n\n    // View helper: amount a user can claim now (post-resolution or cancel)\n    function claimable(address user) external view returns (uint256) {\n        if (hasClaimed[user]) return 0;\n        if (canceled) {\n            // full refund\n            return yesBets[user] + noBets[user];\n        }\n        if (!resolved) return 0;\n        if (winningOutcome == 1 && yesBets[user] > 0) {\n            uint256 payout = (yesBets[user] * getTotalPool()) / totalYesPool;\n            uint256 fee = (payout * feeBps) / 10_000;\n            return payout - fee;\n        } else if (winningOutcome == 0 && noBets[user] > 0) {\n            uint256 payout = (noBets[user] * getTotalPool()) / totalNoPool;\n            uint256 fee = (payout * feeBps) / 10_000;\n            return payout - fee;\n        }\n        return 0;\n    }\n\n    // ============ Fallback ============\n    receive() external payable {}\n}\n"
    }
  }
}